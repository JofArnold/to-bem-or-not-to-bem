---
number: "THE-END"
---

{% extends "../templates/pages/interview.html" %}

{% block biography %}

<p>Front End Engineer with a passion for beautiful UIs.</p>
<p>He has a degree in computer science, and he loves clean and well-tested code. Currently, he is working with React.js, crafting modern JavaScript applications.</p>
<p>Born in Italy, he moved to London with his family to look for new exciting job opportunities. He is a big fan of open source and is always trying to learn something new.</p>

{% endblock %}

{% block interview %}

<div class="dialog dialog--question">
    <p>Hello Michele</p>
    <p>Thanks for accepting my invite to close this series of interviews about BEM.</p>
    <p>For those who don&apos;t know him, Michele &#x2013; pronounced &quot;Mee-keh-leh&quot; as he likes to tell at the beginning of his talks &#x2013; is a dear friend of mine, we are from the same city in Italy, Brescia. He&apos;s been a front-end developer since a long time, and for this reason I absolutely trust his opinions and even more his &quot;instinct&quot;.</p>
    <p>For the same reason, I love our discussions about methodologies, techniques, new ideas and approaches to our work.</p>
    <p>And it was during one of those discussions (street food for lunch in Hoxton Square, Iremember?) that we ended up debating if BEM was a good choice or not.</p>
    <p>I was trying to convince you that BEM was not &quot;needed&quot;, there were other ways to solve the problems it was supposed to solve, while you were explaining me how it made things a lot easier for you and how it was natural read its syntax and understand it after a while.</p>
    <p>Now, I won&apos;t ask you what do you think of that discussion and of BEM in general, I&apos;ll come back to it in a moment.</p>
    <p>Now that you&#x2019;ve become for everyone the reference point for <a href="https://github.com/MicheleBertoli/css-in-js">CSS-in-JS</a>, I would like you to introduce yourself. How do you see yourself today? A front-end developer? A CSS developer? A JavaScript developer? A unicorn? :)</p>
</div>
<div class="dialog dialog--answer">
    <p>First of all, thank you very much for inviting me. It&apos;s a pleasure and an honour to be part of this project. I miss our inspirational lunches in Shoreditch so much btw.</p>
    <p>I moved to London two years and a half ago (I literally decided after a three hours call with Cristiano). In Italy, I used to work in <a href="http://gummyindustries.com/">creative agencies</a> where I grew my passion for cool web stuff. Recently, I moved to the <a href="https://www.bizzby.com/">startup</a> <a href="https://yplanapp.com/">industry</a> where I had the opportunity to improve my JavaScript skills, which lead to me being hired by Facebook.</p>
    <p>When I was building my first React application, I realised that the way I used to design and write my CSS wasn&apos;t a good fit for it and I started looking for Modern&#x2122; solutions. I discovered the CSSinJS world thanks to <a href="https://twitter.com/vjeux">vjeux</a> and I wanted to try all the available packages. From that point on, I talk about writing CSS in JavaScript whenever I can.</p>
    <p>I&apos;ve been recently asked to define myself, and I came out with &quot;Front End Engineer with a passion for beautiful UIs&quot; which for me means that I know about big-O notation, but I love writing HTML and CSS.</p>
    <p>Anyway, you were right about BEM :)</p>
</div>
<div class="dialog dialog--question">
    <p>Wow, I&apos;m absolutely shocked!</p>
    <p>I don&apos;t think I was &quot;right&quot; on BEM, in the sense that I was right in principle, but in the practice of everyday&apos;s life I was wrong (and that&apos;s what is important, that&apos;s the reality of our work). At least this is what my experience in the last year (and this series of interviews) has taught me.</p>
    <p>OK, let&apos;s talk about BEM then, and this &quot;BEM or not to BEM&quot; thing. I know that you were and eager reader of the interviews, but I never asked you anything about them to avoid spoiling this final interview.</p>
    <p>What did you get out of them? What are the &quot;lessons&quot; you have learned, the conclusions you think we can take?</p>
</div>
<div class="dialog dialog--answer">
    <p>Let me explain a little bit more :) You were right saying that BEM was the wrong (unneeded?) solution to the problem. On the other hand, It became the de facto standard, and I find myself comfortable every time I approach a codebase that uses it.</p>
    <p>It is widely adopted and (often) well-understood by developers with different skill sets, which is the biggest win of BEM. I loved this series of interviews since the beginning because it is #forreal.</p>
    <!-- <p>In particular, I believe the format is great because it is more than a typical interview with fixed questions, it&apos;s an informal chat with smart people. The discussion flows naturally, and they share their real experiences. You can read the posts multiple times, and you will always find some new tips.</p> -->
    <p>The key points that emerged from almost all the posts, and contributed to change my mind about the topic, are:</p>
    <p>1 - Pragmatism. You interviewed some of the most skilled people in our industry, and from what they say, avoiding unnecessary formalism is one of the keys to their success.</p>
    <p>2 - &quot;I use BEM but...&quot;. I guess this is a universal opinion. Everyone uses BEM? Nope. Does everyone use their own version of BEM? Exactly. Maybe this is the reason of its diffusion. You can adopt it as a &quot;standard&quot;, you can easily adapt it to the needs of your project/team, and you can still call it BEM.</p>
    <p>3 - Mixing solutions. Using more than one technique seems the way to go. Using BEM with Atomic, and with other approaches, is something that sounds weird if we tend to be strict. Reading this blog, it seems the way to go if you want to ship code.</p>
    <p>4 - Components. Last but not least, I believe this is the central point. Developers adopted BEM because it helped them reasoning about blocks (components?) and elements (components?). Now that we have components, BEM is not needed anymore. In my opinion, this closes the circle.</p>
</div>
<div class="dialog dialog--question">
    <p>&#x201C;Now that we have components, BEM is not needed anymore.&#x201D;. I am pretty sure a lot of people will jump on the chair reading this.</p>
    <p>Personally I agree with you, but only if you slightly change the concept: &#x201C;If you use components, you don&apos;t need BEM anymore&#x201D; where components here is used in the broadest definition as possible (there are many ways to create &quot;web components&quot;, each one with its own pros/cons).</p>
    <p>Regarding web components and CSS &quot;componentization&quot;, nowadays there are many ways to do it especially using Modern&#x2122; solutions (you are the expert, probably you can name dozens of them). In your opinion, which one of them has good chances to become a &quot;de facto standard&quot; like with BEM in the future?</p>
</div>
<div class="dialog dialog--answer">
    <p>I agree: *if you use* components :) And, to quote <a href="06__interview-with--adam__onishi.html">Adam Onishi</a>: (with components) &quot;[...] a lot of what the BEM CSS technique brings to styling will be redundant&quot;. Your question is really interesting, and the answer is not trivial at all.</p>
    <p>In <a href="https://github.com/MicheleBertoli/css-in-js">my repository</a>, I count more than 45 packages. Someone thinks we are all crazy, I strongly believe it&apos;s awesome how in our industry (thanks to the open source) we can create and share experimental solutions to common problems. In this way, we inspire each other and move forward at a very fast pace. Most of the CSSinJS techniques are React-related because React popularised the concept of components and brought a new model of separation of concerns (did you see <a href="https://twitter.com/thomasfuchs/status/810885087214637057">this</a>?), but the majority can be applied to any library or framework.</p>
    <p>My favourite one is CSS Modules, mostly because it&apos;s a non-solution. You need Webpack to make it work, but its behaviour can be easily reproduced with Scoped CSS or Shadow DOM. I like it because it made me write CSS again, without caring so much about naming conventions, complex Sass mixin or variables.</p>
    <p>Components are small and focused, their CSS are simple and easy to maintain. That&apos;s it. I believe CSS Modules (and the concept of &quot;scoped&quot; styles) is here to stay.</p>
    <p>If you want to go a step further, and you compose components with a functional approach, there are the Styled Components. I think Styled Components opened the way to a whole new world. The authors, Glenn Maddern (co-creator of the CSS Modules) and Max Stoiber, really pushed the concept of components to the max. Why create class names that match 1-to-1 your elements, when you can use components? It&apos;s still at the early stage, but I feel that&apos;s the right direction for the future of styling.</p>
</div>
<div class="dialog dialog--question">
    <p>I agree with you, if today I should bet on something it&apos;s CSS Modules :)</p>
    <p>But getting back to what you just said, if you need webpack or other special tools (in most of the cases) how much the solution is actually influenced by the tooling stack and its evolution? Are you sure we are trying to find &quot;solutions to common problems&quot; or aren&apos;t we just trying to find the strangest way to avoid to write CSS at all, leveraging the fact that our tools are &quot;programmable&quot; and so we can take any syntax or declaration of sort and convert it to CSS in output?</p>
</div>
<div class="dialog dialog--answer">
    <p>I understand your point, but I think it has always been like that. Aren&apos;t Sass or Less just tools we use to avoid writing CSS? I can&apos;t see any difference, apart from the fact that the new solutions tend to use JavaScript. CSS have been created to style documents, while we build web applications using components. It seems natural to me that something has to change.</p>
</div>
<div class="dialog dialog--question">
    <p>Well, the evolution from CSS to Less/Sass/Stylus etc. it&apos;s been pretty slick at the end. It&apos;s been a change of syntax and file architecture/organisation, but the core remained the same. While the recent JavaScript-based implementations take the game to a completely new level, are definitely disruptive. And that&apos;s also why are so controversial and generate so much &quot;heat&quot; in the community.</p>
    <p>And regarding this shift from building web-pages to building web-applications, have you seen <a href="https://twitter.com/sebmarkbage/status/811348741143699457">this tweet</a> by Sebastian Markb&#xE5;ge yesterday?</p>
    <p>Clearly the web is forking, but do you think the web should &quot;concede defeat&quot; to native applications, like PPK suggested? Because in my experience, even in my daily job, I think is the opposite.</p>
</div>
<div class="dialog dialog--answer">
    <p>Today we are used to pre-processors, but the first time I saw one I thought: what kind of sorcery is this? That&apos;s not real CSS, and you lose control over the bundle? Why should I add a build step to my workflow? Gulp or Grunt? We could split and import partials, create mixins, extend classes. Pre-processors changed completely the way we used to approach CSS, but since they didn&apos;t touch the other &quot;concerns&quot; they have been accepted.</p>
    <p>Sebastian&apos;s post is awesome, and I agree when he says that the future of the web is &quot;very interesting&quot;. The web is forking, and I couldn&apos;t be more excited. PPK is on point saying that websites are often over-engineered, and they sometimes offer a bad UX (e.g. scroll hijacking) but I don&apos;t believe the web should concede defeat.</p>
    <p>My personal feeling is that the web has a bright future and when the platform (as a whole) will be good enough, we should rethink the role of native applications instead. I recently attended <a href="https://ldnwebperf.org/events/progressive-web-apps-with-jake-archibald/">a talk by Jack Archibald</a>) that blown my mind about how browsers are evolving and how many possibilities we are going to have in the near future.</p>
</div>
<div class="dialog dialog--question">
    <p>Mmm, not sure if I agree with you on the first part of your comment, about pre-processors: of course they introduced new methods of writing CSS, but was still the same game at the end. But I want to move on, so probably matter for a new discussion at lunchtime.</p>
    <p>I want to come back to what you said above about the &quot;experimental solutions&quot;. I totally get the exploration and inspiration and moving the web forward.</p>
    <p>But then these experimental solutions end up in real production code, in real business products. They enter in the &quot;master&quot; codebase of a company, not only in personal side projects.</p>
    <p>And I don&apos;t have problem with that, as soon as a company is aware of the risks and possible downsides of adopting emerging technologies, that sometimes are mastered only by a few bunch of people, if not in some cases by the one developer inside the company that wants to try something new, cool and Modern&#x2122; and doesn&apos;t care (or realise) that then this code will need to be maintained and updated, possibly for a few years to come.</p>
    <p>Which at the end is what a lot of &quot;old school&quot; developers and ma&#xEE;tre a penser contest: that these approaches and techniques are not sustainable on the long term, are throwaway methodologies that will be replaced by the next cycle of hype.</p>
    <p>What do you think?</p>
</div>
<div class="dialog dialog--answer">
    <p>Wow, this is a fascinating topic. I found myself multiple times in the position where I could choose the shiny new technology VS staying safe. I believe that having a high level of seniority :) help with that, but (as you said) it&apos;s always a risky decision for the company.</p>
    <p>I guess it also highly depends on the industry. For example, when I used to work in creative agencies on short-term projects (e.g. marketing campaigns) I was asked to choose the latest crazy cool stuff. Then I moved to startups where projects are potentially (and hopefully) long-terms, but you still bet every single day on the future of the product.</p>
    <p>I firmly believe there should always be a reason for when you invest in experimental solutions, and that reason should not be that someone tweeted about it.</p>
    <p>To accurately answer your question, I would like to share my personal experience (which is the essence of this project). At <a href="https://yplanapp.com/">YPlan</a>, my previous company, I was leading the front-end team, and we have been asked to create a &quot;framework&quot; which we could use to build new UIs quickly. We were developing a new Portal for our partners, and we used to work iteratively, doing a lot of user testing.</p>
    <p>For that reason, we wanted to be able to create and destroy interfaces without wasting time and iterate fast. Our primary product was built with React and Sass+BEM. We decided (of course :)) to keep React, but we wanted to take a step further on the componentization and avoid following a naming convention.</p>
    <p>The natural solution was CSS Modules. I believe that moving to CSS Modules doesn&apos;t require to be brave because, with a simple command, you can extract the CSS (tweaking the class names as you wish).</p>
    <p>The &quot;crazy&quot; part was when we decided to try the Atomic CSS. I heard (at FEL) that, with Atomic CSS, you could prototype UIs quickly and that was exactly our goal. On the other hand, we didn&apos;t want to pollute the markup with tens of classes. That&apos;s why we decided to use <a href="https://medium.com/yplan-eng/atomic-css-modules-cb44d5993b27#.3jntjcgpo">CSS Modules to compose our Atomic classes</a> inside the CSS.</p>
    <p>How did we know that was a good solution? How could we make sure we weren&apos;t creating a technical debt? The first step we took has been building a prototype to see if the solution could work and it was flexible enough to cover all the cases. At that point, the most important thing was for everyone in the team to agree. We shared the demo with the rest of the company, and people was impressed with the speed in which we could create and destroy interfaces (keeping the size of the CSS under control).</p>
    <p>When everyone is on board, the second thing I learned is to fail fast. Go and build the most sophisticated interface and see how it goes, don&apos;t wait for the experimental solution to polluting your codebase. Timeout has now acquired the startup and lot of new developers are going to work on the codebase.</p>
    <p>My ex-colleague <a href="https://twitter.com/elmotta">Lucas</a> had to do the handover but since we documented all the decisions with blog posts and presentations he didn&apos;t have any problems.</p>
    <p>To recap, the key points are: - bet on experimental solutions only if they solve a real problem - get everyone on board and document your decisions - fail fast and prepare a backup plan It worked very well for us :)</p>
</div>
<div class="dialog dialog--question">
    <p>Now, let me do the devil&apos;s advocate here, because you were too good in your answer (probably because it&apos;s Christmas).</p>
    <p>Recently I have started to ask myself if all this &quot;code quality&quot;, and clean codebase, and refactoring to reduce the technical debt are just myths, or illusions.</p>
    <p>What I have seen are two kind of projects: those that once created and deployed are left there untouched forever, and those that are then maintained day by day, month by month, accumulating workarounds and patches and &quot;we&apos;ll fix later&quot;, and a whole team dreaming of a future moment in which there will be time to do things properly.</p>
    <p>But this time never comes because the company collapses (see VisualDNA), gets acquired (see Yplan) or decides to completely re-design the product and at that point the old codebase is simply ditched and a new clean &quot;master&quot; branch sees the light, just to end up in the same situation a few months later.</p>
    <p>So all this principles of maintainability, future-proof code, technical choices that can span years of lifecycle of a product, are just a gimmick.</p>
    <p>At the end if our code is throwaway, why should we bother to write clean code, to fight against the technical debt, to imagine architectures and introduce methodologies and care about the code?</p>
    <p>Why in that sense Sass+BEM is a better choice compared to CSSinJS, if both are destined to never be touched again or be replaced in a few months? (I remember reading somewhere that typically there is a complete redesign/refactoring of a project every 12-16 months, and that resonates a lot with my experience)</p>
</div>
<div class="dialog dialog--answer">
    <p>I can confirm I&apos;ve only seen those two types of projects in my career, too. I always thought I would find the long-lived well-architectured codebase sooner or later. Maybe in my next experience :)</p>
    <p>However, to me, the technical debt doesn&apos;t only apply to the long terms (years). How quickly it is to change the code you wrote this morning? That&apos;s why, for example, I prefer to use a tool like CSS Modules that scopes the class names for me rather than a methodology, such as BEM, that makes me overthink and spend time on non-so-important things.</p>
    <p>I like to focus on building features and creating value for the users; that&apos;s it. My goal is writing code that is easy to delete.</p>
</div>
<div class="dialog dialog--question">
    <p>Reading the interviews, and you also noticed it, one thing stands out: everyone tends to pick and choose (and adapt/customise) different parts from different methodologies. BEM + OOCSS + Atomic, BEM + Helpers + OOCSS, etc.</p>
    <p>Is it the same also with Modern&#x2122; CSS? For example you have mixed <a href="https://medium.com/yplan-eng/atomic-css-modules-cb44d5993b27#.bgnitu99f">CSS Modules and Atomic</a>. In general do you see people use different approaches and mix them together? Or instead there are clear choices, where one exclude the other?</p>
    <p>And this also leads to a second question, related to being &quot;strict&quot; or &quot;loose&quot; in how you use these methodologies: everyone does BEM-ish, people use BEM but with &quot;exceptions&quot; and &quot;special cases&quot;.</p>
    <p>All the naming conventions and CSS methodologies rely on a strong self-discipline of the developers (especially in a team work with a shared codebase).</p>
    <p>Is it the same for the CSSinJS, CSS Modules and so on? Or each developer can choose his/her own syntax flavour and this is not a problem because somehow is confined inside a component?</p>
</div>
<div class="dialog dialog--answer">
    <p>Yes, not being strict and mixing methodologies was one of the most surprising things I learned reading these interviews.</p>
    <p> I always felt guilty when I couldn&apos;t follow the rules for some reasons, and hearing that strong skilled people are doing that made me feel better :)</p>
    <p>In the CSSinJS world, we talk more about technologies than methodologies. For example mixing Atomic and CSS Modules is more similar to mixing Atomic and Sass, rather than Atomic and BEM.</p>
    <p>In general, I can see people choosing one library and sticking to it. A typical pattern is creating a layer between components and the styling library in a way that components are not aware of it, and it can be replaced easily. For safety, I guess. The fact that CSSinJS are libraries, also means that usually there are no rules or conventions to follows.</p>
    <p>As you said, with these solutions styles tend to be small and focused and there&apos;s no need for creating complex architectures. This is one of the reasons I believe regular CSS are not the perfect fit for components while locally scoped classes or &quot;inline styles&quot; (co-locating styles within the components) work better.</p>
    <p>If you split the components in the right way, you end up having a few styling rules for each one of them and the maintainability is not a problem anymore.</p>
    <p>Additionally, most of the solutions generate the class names for you using unique hashes which mean that you can use whatever naming convention you prefer.</p>
    <p>For example, you can call a button just &quot;button&quot; :)</p>
</div>
<div class="dialog dialog--question">
    <p>That&apos;s why I like so much the idea of CSS Modules. But trust me, you can do the same with BEM or even only with a correct name-spacing. But I have realised (sometimes the hard way) that this doesn&apos;t work well when there is more than one developer involved in a project, or at least if not all the members of the team follow the same rules ;)</p>
</div>

{% endblock %}
